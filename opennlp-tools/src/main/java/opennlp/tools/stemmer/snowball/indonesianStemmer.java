// CHECKSTYLE:OFF
/*

Copyright (c) 2010, Israel Olalla
Copyright (c) 2010, ISOCO
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice,
    * this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
    * notice, this list of conditions and the following disclaimer in the
    * documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holders nor the names of its contributors
    * may be used to endorse or promote products derived from this software
    * without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

 */

// Generated by Snowball (build from 867c4ec70debd4daa7fb4d5a9f7759b47887d0b9)
package opennlp.tools.stemmer.snowball;


/**
 * This class implements the stemming algorithm defined by a snowball script.
 * <p>
 * Generated by Snowball (build from 867c4ec70debd4daa7fb4d5a9f7759b47887d0b9) - <a href="https://github.com/snowballstem/snowball">https://github.com/snowballstem/snowball</a>
 * </p>
 */
@SuppressWarnings("unused")
public class indonesianStemmer extends AbstractSnowballStemmer {


  private final static Among a_0[] = {
      new Among("kah", -1, 1),
      new Among("lah", -1, 1),
      new Among("pun", -1, 1)
  };

  private final static Among a_1[] = {
      new Among("nya", -1, 1),
      new Among("ku", -1, 1),
      new Among("mu", -1, 1)
  };

  private final static Among a_2[] = {
      new Among("i", -1, 1, "r_SUFFIX_I_OK", indonesianStemmer.class),
      new Among("an", -1, 1, "r_SUFFIX_AN_OK", indonesianStemmer.class),
      new Among("kan", 1, 1, "r_SUFFIX_KAN_OK", indonesianStemmer.class)
  };

  private final static Among a_3[] = {
      new Among("di", -1, 1),
      new Among("ke", -1, 2),
      new Among("me", -1, 1),
      new Among("mem", 2, 5),
      new Among("men", 2, 1),
      new Among("meng", 4, 1),
      new Among("meny", 4, 3, "r_VOWEL", indonesianStemmer.class),
      new Among("pem", -1, 6),
      new Among("pen", -1, 2),
      new Among("peng", 8, 2),
      new Among("peny", 8, 4, "r_VOWEL", indonesianStemmer.class),
      new Among("ter", -1, 1)
  };

  private final static Among a_4[] = {
      new Among("be", -1, 3, "r_KER", indonesianStemmer.class),
      new Among("belajar", 0, 4),
      new Among("ber", 0, 3),
      new Among("pe", -1, 1),
      new Among("pelajar", 3, 2),
      new Among("per", 3, 1)
  };

  private static final char g_vowel[] = {17, 65, 16};

  private int I_prefix;
  private int I_measure;


  private boolean r_remove_particle() {
    ket = cursor;
    if (find_among_b(a_0) == 0) {
      return false;
    }
    bra = cursor;
    slice_del();
    I_measure -= 1;
    return true;
  }

  private boolean r_remove_possessive_pronoun() {
    ket = cursor;
    if (find_among_b(a_1) == 0) {
      return false;
    }
    bra = cursor;
    slice_del();
    I_measure -= 1;
    return true;
  }

  public boolean r_SUFFIX_KAN_OK() {
    if (I_prefix == 3) {
      return false;
    }
    if (I_prefix == 2) {
      return false;
    }
    return true;
  }

  public boolean r_SUFFIX_AN_OK() {
    return I_prefix != 1;
  }

  public boolean r_SUFFIX_I_OK() {
    if (I_prefix > 2) {
      return false;
    }
    {
      int v_1 = limit - cursor;
      lab0:
      {
        if (!(eq_s_b("s"))) {
          break lab0;
        }
        return false;
      }
      cursor = limit - v_1;
    }
    return true;
  }

  private boolean r_remove_suffix() {
    ket = cursor;
    if (find_among_b(a_2) == 0) {
      return false;
    }
    bra = cursor;
    slice_del();
    I_measure -= 1;
    return true;
  }

  public boolean r_VOWEL() {
    if (!(in_grouping(g_vowel, 97, 117))) {
      return false;
    }
    return true;
  }

  public boolean r_KER() {
    if (!(out_grouping(g_vowel, 97, 117))) {
      return false;
    }
    if (!(eq_s("er"))) {
      return false;
    }
    return true;
  }

  private boolean r_remove_first_order_prefix() {
    int among_var;
    bra = cursor;
    among_var = find_among(a_3);
    if (among_var == 0) {
      return false;
    }
    ket = cursor;
    switch (among_var) {
      case 1:
        slice_del();
        I_prefix = 1;
        I_measure -= 1;
        break;
      case 2:
        slice_del();
        I_prefix = 3;
        I_measure -= 1;
        break;
      case 3:
        I_prefix = 1;
        slice_from("s");
        I_measure -= 1;
        break;
      case 4:
        I_prefix = 3;
        slice_from("s");
        I_measure -= 1;
        break;
      case 5:
        I_prefix = 1;
        I_measure -= 1;
        lab0:
        {
          int v_1 = cursor;
          lab1:
          {
            int v_2 = cursor;
            if (!(in_grouping(g_vowel, 97, 117))) {
              break lab1;
            }
            cursor = v_2;
            slice_from("p");
            break lab0;
          }
          cursor = v_1;
          slice_del();
        }
        break;
      case 6:
        I_prefix = 3;
        I_measure -= 1;
        lab2:
        {
          int v_3 = cursor;
          lab3:
          {
            int v_4 = cursor;
            if (!(in_grouping(g_vowel, 97, 117))) {
              break lab3;
            }
            cursor = v_4;
            slice_from("p");
            break lab2;
          }
          cursor = v_3;
          slice_del();
        }
        break;
    }
    return true;
  }

  private boolean r_remove_second_order_prefix() {
    int among_var;
    bra = cursor;
    among_var = find_among(a_4);
    if (among_var == 0) {
      return false;
    }
    ket = cursor;
    switch (among_var) {
      case 1:
        slice_del();
        I_prefix = 2;
        I_measure -= 1;
        break;
      case 2:
        slice_from("ajar");
        I_measure -= 1;
        break;
      case 3:
        slice_del();
        I_prefix = 4;
        I_measure -= 1;
        break;
      case 4:
        slice_from("ajar");
        I_prefix = 4;
        I_measure -= 1;
        break;
    }
    return true;
  }

  public boolean stem() {
    I_measure = 0;
    int v_1 = cursor;
    lab0:
    {
      while (true) {
        int v_2 = cursor;
        lab1:
        {
          golab2:
          while (true) {
            lab3:
            {
              if (!(in_grouping(g_vowel, 97, 117))) {
                break lab3;
              }
              break golab2;
            }
            if (cursor >= limit) {
              break lab1;
            }
            cursor++;
          }
          I_measure += 1;
          continue;
        }
        cursor = v_2;
        break;
      }
    }
    cursor = v_1;
    if (I_measure <= 2) {
      return false;
    }
    I_prefix = 0;
    limit_backward = cursor;
    cursor = limit;
    int v_4 = limit - cursor;
    r_remove_particle();
    cursor = limit - v_4;
    if (I_measure <= 2) {
      return false;
    }
    int v_5 = limit - cursor;
    r_remove_possessive_pronoun();
    cursor = limit - v_5;
    cursor = limit_backward;
    if (I_measure <= 2) {
      return false;
    }
    lab4:
    {
      int v_6 = cursor;
      lab5:
      {
        int v_7 = cursor;
        if (!r_remove_first_order_prefix()) {
          break lab5;
        }
        int v_8 = cursor;
        lab6:
        {
          int v_9 = cursor;
          if (I_measure <= 2) {
            break lab6;
          }
          limit_backward = cursor;
          cursor = limit;
          if (!r_remove_suffix()) {
            break lab6;
          }
          cursor = limit_backward;
          cursor = v_9;
          if (I_measure <= 2) {
            break lab6;
          }
          if (!r_remove_second_order_prefix()) {
            break lab6;
          }
        }
        cursor = v_8;
        cursor = v_7;
        break lab4;
      }
      cursor = v_6;
      int v_10 = cursor;
      r_remove_second_order_prefix();
      cursor = v_10;
      int v_11 = cursor;
      lab7:
      {
        if (I_measure <= 2) {
          break lab7;
        }
        limit_backward = cursor;
        cursor = limit;
        if (!r_remove_suffix()) {
          break lab7;
        }
        cursor = limit_backward;
      }
      cursor = v_11;
    }
    return true;
  }

  @Override
  public boolean equals(Object o) {
    return o instanceof indonesianStemmer;
  }

  @Override
  public int hashCode() {
    return indonesianStemmer.class.getName().hashCode();
  }


}

